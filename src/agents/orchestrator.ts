import { createLogger } from "@/utils/logger.ts";
import type { Config } from "@/config/schema.ts";
import { HouseMasterAgent } from "@/agents/house-master.ts";
import { ClaudeCodeAgentPool } from "@/agents/claude-code.ts";
import { getIssue, getIssueComments, addIssueComment, addIssueLabels } from "@/github/issues.ts";
import { createPullRequest, getPRDiff, addPRReview, getPullRequest } from "@/github/pull-requests.ts";
import { formatAgentComment } from "@/github/comments.ts";

const logger = createLogger("orchestrator");

export interface IssueTask {
  repo: string;
  number: number;
  title: string;
  body: string;
  labels: string[];
  author: string;
}

export interface PRTask {
  repo: string;
  number: number;
  title: string;
  body: string;
  headBranch: string;
  baseBranch: string;
  author: string;
}

export interface MentionTask {
  repo: string;
  issueNumber: number;
  commentId: number;
  body: string;
  author: string;
}

export interface CommandTask {
  repo: string;
  issueNumber: number;
  command: string;
  args: string[];
  author: string;
}

export interface PRRevisionTask {
  repo: string;
  prNumber: number;
  comment: string;
  author: string;
}

export class Orchestrator {
  private config: Config;
  private houseMaster: HouseMasterAgent;
  private claudeCodePool: ClaudeCodeAgentPool;
  private repoPath: string;
  private processingIssues: Set<string> = new Set();

  constructor(config: Config, repoPath: string) {
    this.config = config;
    this.repoPath = repoPath;
    this.houseMaster = new HouseMasterAgent(config);
    this.claudeCodePool = new ClaudeCodeAgentPool(config, repoPath, {
      maxWorkers: 3,
    });
  }

  async init(): Promise<void> {
    await this.claudeCodePool.init();
    logger.info("Orchestrator initialized");
  }

  async processIssue(task: IssueTask): Promise<void> {
    const issueKey = `${task.repo}:${task.number}`;

    if (this.processingIssues.has(issueKey)) {
      logger.warn({ issueKey }, "Issue already being processed");
      return;
    }

    this.processingIssues.add(issueKey);

    try {
      logger.info({ repo: task.repo, number: task.number }, "Processing issue");

      const [issue, comments] = await Promise.all([
        getIssue(task.repo, task.number),
        getIssueComments(task.repo, task.number),
      ]);

      const analysis = await this.houseMaster.analyzeIssue(issue, this.repoPath, comments);

      logger.info({ issueNumber: task.number, analysis }, "Issue analysis complete");

      // Silently add labels
      if (analysis.suggestedLabels.length > 0) {
        try {
          await addIssueLabels(task.repo, task.number, analysis.suggestedLabels);
        } catch (error) {
          logger.warn({ error }, "Failed to add labels");
        }
      }

      // Ask for clarification if requirements are unclear
      if (analysis.needsClarification && analysis.clarificationQuestion) {
        await addIssueComment(
          task.repo,
          task.number,
          formatAgentComment(
            "HouseMaster",
            `I need some clarification before I can work on this:\n\n${analysis.clarificationQuestion}\n\nPlease provide more details and I'll get started!`
          )
        );
        return;
      }

      // Only comment when human attention is needed
      if (analysis.assignTo === "human") {
        await addIssueComment(
          task.repo,
          task.number,
          formatAgentComment(
            "HouseMaster",
            `This issue requires human attention.\n\n**Reasoning:** ${analysis.reasoning}`
          )
        );
        return;
      }

      // Log subtask split but don't spam comments
      if (analysis.shouldSplit && analysis.subtasks.length > 0) {
        logger.info({ issueNumber: task.number, subtasks: analysis.subtasks }, "Issue should be split");
      }

      const result = await this.claudeCodePool.executeTask(issue, task.repo);

      if (!result.success) {
        await addIssueComment(
          task.repo,
          task.number,
          formatAgentComment(
            "Haunted",
            `Implementation failed: ${result.error || "Unknown error"}\n\nA human developer may need to take a look.`
          )
        );
        return;
      }

      const pr = await createPullRequest({
        repo: task.repo,
        title: `fix: ${issue.title}`,
        body: `## Summary

${result.summary}

Closes #${issue.number}

---
ðŸ¤– *Generated by Haunted AI*`,
        head: result.branchName,
        base: "main",
      });

      await addIssueComment(
        task.repo,
        task.number,
        formatAgentComment("Haunted", `Created PR #${pr.number}`)
      );

      logger.info({ repo: task.repo, issueNumber: task.number, prNumber: pr.number }, "PR created for issue");
    } catch (error) {
      logger.error({ error, issueKey }, "Failed to process issue");
      // Don't spam issue with error comments - just log it
    } finally {
      this.processingIssues.delete(issueKey);
    }
  }

  async reviewPullRequest(task: PRTask): Promise<void> {
    logger.info({ repo: task.repo, number: task.number }, "Reviewing PR");

    try {
      const pr = await getPullRequest(task.repo, task.number);
      const diff = await getPRDiff(task.repo, task.number);

      const review = await this.houseMaster.reviewPullRequest(pr, diff, this.repoPath);

      const event = review.approved ? "APPROVE" : "REQUEST_CHANGES";

      let reviewBody = review.overallFeedback;
      if (review.suggestedChanges.length > 0) {
        reviewBody += `\n\n**Suggestions:**\n${review.suggestedChanges.map((c) => `- ${c}`).join("\n")}`;
      }

      await addPRReview({
        repo: task.repo,
        number: task.number,
        event,
        body: reviewBody,
      });

      logger.info(
        { repo: task.repo, prNumber: task.number, approved: review.approved },
        "PR review submitted"
      );
    } catch (error) {
      logger.error({ error, repo: task.repo, prNumber: task.number }, "Failed to review PR");
    }
  }

  async cancelIssueProcessing(repo: string, issueNumber: number): Promise<void> {
    const issueKey = `${repo}:${issueNumber}`;

    if (this.processingIssues.has(issueKey)) {
      await this.claudeCodePool.cancelTask(repo, issueNumber);
      this.processingIssues.delete(issueKey);
      logger.info({ repo, issueNumber }, "Issue processing cancelled");
    }
  }

  async handlePRMerged(repo: string, prNumber: number): Promise<void> {
    logger.info({ repo, prNumber }, "Handling merged PR");
    // Cleanup worktrees and resources associated with this PR
  }

  async handleMention(task: MentionTask): Promise<void> {
    logger.info({ repo: task.repo, issueNumber: task.issueNumber }, "Handling mention");

    try {
      const issue = await getIssue(task.repo, task.issueNumber);
      const context = `Issue #${issue.number}: ${issue.title}\n\n${issue.body}\n\nUser ${task.author} commented:`;

      const response = await this.houseMaster.generateResponse(
        context,
        task.body,
        this.repoPath
      );

      await addIssueComment(
        task.repo,
        task.issueNumber,
        formatAgentComment("Haunted", response)
      );
    } catch (error) {
      logger.error({ error }, "Failed to handle mention");
    }
  }

  async handleCommand(task: CommandTask): Promise<void> {
    logger.info({ repo: task.repo, issueNumber: task.issueNumber, command: task.command }, "Handling command");

    const commands: Record<string, () => Promise<void>> = {
      retry: async () => {
        const issue = await getIssue(task.repo, task.issueNumber);
        await this.processIssue({
          repo: task.repo,
          number: issue.number,
          title: issue.title,
          body: issue.body,
          labels: issue.labels,
          author: issue.author,
        });
      },
      cancel: async () => {
        await this.cancelIssueProcessing(task.repo, task.issueNumber);
        await addIssueComment(
          task.repo,
          task.issueNumber,
          formatAgentComment("Haunted", "Cancelled.")
        );
      },
      status: async () => {
        const isProcessing = this.processingIssues.has(`${task.repo}:${task.issueNumber}`);
        const status = isProcessing ? "Processing" : "Idle";
        await addIssueComment(
          task.repo,
          task.issueNumber,
          formatAgentComment("Haunted", `Status: ${status}`)
        );
      },
    };

    const handler = commands[task.command];
    if (handler) {
      await handler();
    } else {
      // Unknown command - just ignore, don't spam
      logger.warn({ command: task.command }, "Unknown command");
    }
  }

  async handlePRRevisionRequest(task: PRRevisionTask): Promise<void> {
    const prKey = `pr:${task.repo}:${task.prNumber}`;

    if (this.processingIssues.has(prKey)) {
      logger.warn({ prKey }, "PR revision already in progress");
      return;
    }

    this.processingIssues.add(prKey);

    try {
      logger.info({ repo: task.repo, prNumber: task.prNumber }, "Processing PR revision request");

      const pr = await getPullRequest(task.repo, task.prNumber);

      // Only process PRs created by haunted
      if (!pr.headBranch.startsWith(this.config.agents.claude_code.branch_prefix)) {
        logger.info({ prNumber: task.prNumber }, "PR not created by haunted, skipping");
        return;
      }

      const result = await this.claudeCodePool.executeRevision(pr, task.repo, task.comment);

      if (!result.success) {
        await addIssueComment(
          task.repo,
          task.prNumber,
          formatAgentComment(
            "Haunted",
            `Failed to apply revision: ${result.error || "Unknown error"}`
          )
        );
        return;
      }

      await addIssueComment(
        task.repo,
        task.prNumber,
        formatAgentComment(
          "Haunted",
          `Applied revisions based on your feedback.\n\n**Changes:**\n${result.filesChanged.map((f) => `- ${f}`).join("\n")}`
        )
      );

      logger.info({ repo: task.repo, prNumber: task.prNumber }, "PR revision applied");
    } catch (error) {
      logger.error({ error, prKey }, "Failed to process PR revision");
    } finally {
      this.processingIssues.delete(prKey);
    }
  }

  async cleanup(): Promise<void> {
    await this.claudeCodePool.cleanup();
    this.processingIssues.clear();
    logger.info("Orchestrator cleaned up");
  }
}
